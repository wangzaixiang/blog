# Design By Contract 浅析

今年，我们在项目中开始进行了Design By Contract(本文中简称为DBC)的实践，在提高软件质量方面，取得了一定的效果。但是，不少开发人员还是没有很好的理解这一个方法，本文将对这一个工具进行解析，期待会相关开发人员提供帮助。

1. 起源
	Design By Contract 最早是 Bertrand Meyer 教授提出来的一种设计方法，Meyer教授还为此设计过 eiffel 这样一门编程语言，直接内置了 DBC 这一方法。在 Meyer 教授看来，DBC 是一个基本的编程模式，也是一种最基本的设计模式，应该直接内置在编程语言之中。

	我最早学习面向对象语言时，接触到Eiffel这门语言时，就深深的被起吸引，相比当时的主流面向对象语言C++，Eiffel还支持自动内存管理（GC），当然，对其 DBC 的理念是深表赞同。

2. 何谓 Design By Contract
	DBC是一种程序设计方式，通过强调使用规格化、精确、可验证的的方式来描述软件接口，来达到软件接口的语义化和更好的质量控制。

	描述接口的合约（Contract）包括三个部分：
	- 前置条件(preconditions): 在接口执行之前，必须满足的条件。接口调用者（consumer）负责保证前置条件，
	- 后置条件(postconditions：在接口执行之后，服务必须承诺的条件。接口实现者（supplier)负责保证后置条件。
	- 不变量(invariants)：对给定的对象，无论调用哪个接口，对象上都必须保证满足的条件。

	下面是一个eiffel语言的代码范例：
		class DICTIONARY [ELEMENT]
		feature
			put (x: ELEMENT; key: STRING) is
			  -- Insert x so that it will be retrievable
			  -- through key.
			  require
				count <= capacity
				not key.empty 
			  ensure
				has (x)
				item (key) = x
				count = old count + 1
			  end
		
			... Interface specifications of other features ...
		
		invariant
			0 <= count
			count <= capacity
		end

3. 相关的技术和方法
	1. 断言 assertion
		在C语言中，引入了 assert 概念，虽然仅仅是一个macro，但assert被认为是保证软件质量很重要的一种手段。

		在wikipedia中是这样定义断言的：断言是一个布尔表达式，它总是期待返回true，如果在运行时这个表达式的值为false，那么一定是软件出现了预料之外的Bug，系统应该奔溃，或者产生一个断言异常。 

		在C标准库中，assert失败的直接结果，就是程序马上退出，并在控制台显示一个断言失败的提示信息。相当粗鲁的方式。

		或许正是因为assertion是一种有效的提高开发质量的手段，在Java 1.4 中正式把他作为一个关键字引入进来。一个特性上升为一门语言的关键字，应该是这门语言对这个特性的最隆重的敬意了。

	2. fail fast 
		这个翻译为中文或许应该叫走 “快速死亡“ 了。也是一种软件设计的思想。区别于”容错“的设计，fail fast的设计原则就是，如果检测到系统出现非预期的错误时，不是勉强“容错”，而是快速失败，不要做无谓的努力了。

		这个思想是如此的奇特，以至于这样的系统还有质量保证吗？但居然fail fast的原则居然就是为了设计对质量有极高要求的高可用系统而采用的原则。在这方面，最典型的案例就是 erlang 的 actor 模型，akka的actor模型也是采用了同样的设计理念。

		在actor模型中，采用fail fast可以让失败的代码快速死亡，而不要继续将错就错，当然，上层代码可以快速的切换到一个新的正确的actor继续进行执行，从而保证整个系统的高可用性。
		 
4. DBC 的价值
	DBC 有 两个层面的价值，其一是作为一种接口（服务）设计的语义化工具，提供一种形式化的、精确、无歧义的方式来描述接口的契约。其二是作为一种代码质量保障的工具，提高系统的质量。在我看来，这两个价值都是十分重要的内容，前者面向设计，后者面向开发和运行质量。如此重要的特性，在没有语言直接支持的情况下，难怪 Meyer 需要单独设计一门语言来支持他。

	我一直从事事务类应用（通俗的说，也就是数据库应用）的开发工作，在多年的开发工作经验中，我觉得DBC在事务类应用中更是神器，很多的问题，不应用DBC的方法，很容易就陷入到BUG的泥坑之中。也一直期待能够有一门语言能够直接内置的支持DBC的设计思想，不过，到目前为止还是一种奢求。即便连语言能力最为丰富的 scala 也没有内置这个特性的支持。

	- 作为服务接口设计的工具。
		在大部分的互联网公司，都已经将SOA作为一种基本的架构（区别于对应的一体化系统），在SOA架构中，最为重要的就是Service接口的设计。我们期待着一种能够很好的描述服务语义的设计工具。具有良好的语义设计服务接口是服务化中的核心关键。

		我们可以使用 IDL 之类的工具来精确化定义服务接口的输入、输出，这个相比文档工具更为有效。但IDL仍然无法帮助我们定义出这个接口是做什么的？

		DBC 对每一个接口采用 preconditions, postconditions 可以帮助我们来描述服务接口的语义：

		- preconditions 前置条件定义了调用接口的条件，包括请求参数的约束、数据实体当前的状态约束、甚至于当前操作员的访问权限约束。事实上，在事务类应用中，preconditions是如此的重要，以至于会出现很多的服务，单preconditions都可能会比execution更为复杂，也更为重要。不做前置条件检查，就直接进行逻辑处理的工程师，要么是菜鸟，无此经验，不考虑任何异常条件就直奔主题。要么就是没有责任感的工程师。（凭此来作为工程师能力考究，是一种有效的手段）
		- postconditions 服务怎么做，这个是一个复杂的话题，但服务做什么，产生了什么副作用，这个是服务最原始的需求。那么如何描述服务做什么呢？post conditions其实是提供了一种还算有效的方式来表述这个能力。

	- 作为代码质量保证的工具。
		提高代码质量的方式有很多，assertion是一种手段，单元测试也是一种有效的手段。敏捷开发非常强调单元测试，无单元测试不敏捷开发。但是，在笔者看来，还有一种更为重要的手段是postconditions和invariant的技术。甚至来说，你也可以认为DBC是一种增强的单元测试。

		一般来说，我们进行单元测试更多的是场景测试，偏重于对一个业务场景的测试，在单元测试中通过大量的assertion来监测接口调用后的副作用。post condition其实是另外一个角度的测试，而且是从服务接口语义的角度上来保证，每次调用接口时都进行一次post conditions 的检查，就相当于将单个业务场景下的断言扩展到了每一次的调用上。

		而在复杂的数据模型场景下，invariants的价值就更大了。在事务类应用中，往往会在数据模型中存在较大的信息冗余（可能是出于性能的需求，也可能是分离关注点更好的结构化的原因），以及复杂的状态变迁。在复杂的状态变迁中，最容易出现的问题就是数据的不一致性。（当然，由于分布式场景也会带来一定的数据不一致的情况）。很多的数据库不一致我们可以通过DB schema来进行解决，如 Foreign Key， Not Null， Unique Index 等，但更多的情况是数据库引擎所无能为力的。

		单元测试对这种检查很多时候是无能为力的，单元测试更多的是针对特定的场景进行问题监测。数据不一致性出现后，很多时候并不会马上发现，然后系统就带病执行，直到最后的某个时间点才爆发出来。不过，那个时候，可能已经完了，或许会产生一些意想不到的事故发生。这个时候，fail fast的原则就可以派上用场了。尤其是在测试阶段、试运行阶段，更需要及早的暴露错误，马上处理。理论上，在生产阶段，也是很有价值的。

		在我们现在的订单系统中，我们的一个对象上的不变量检查就可能多达近100个检查，每一个检查点相当于为我们的服务添加了一个质量把关，让错误及早显形。
		 
5. 为什么是DBC
	软件是人制造出来的复杂性，无论如何努力，都难以消除Bug。而互联网行业更加的追求敏捷响应，在项目节奏上更加快速紧凑了，在这种情况，Bug的挑战更大。

	一般来说，我们使用C、Java这一类的命令式语言来编程，我们定义好我们的目标之后，就开始应用How to do 的思维模式来从无到有的构思软件。How的方式是最为复杂的，因为其牵涉到复杂的执行状态变更、负责的执行路线组合，最终在经意或不经意间埋下Bug。

	然后，我们开始尝试 What to do 的函数式语言，使用SQL来替代复杂的数据操作，What 基于一个很高的抽象，使得我们可以在这个抽象的基础上，摒弃掉对过程的思考，而关注于采用一种形式化的方式来描述我们的目标。高级语言使得我们可以使用更高的抽象来替代底层的How to do过程，函数式语言可以使用高阶函数来描述数据的变换过程。

	从这个角度上来看，DBC也是这种思路的一个实践，他抛弃了描述过程的复杂性，也无须追求对服务实现过程的精确描述，而更多的是对服务结果的约束描述。如果上升到哲学的角度来思考，How为动，What为静，以静制动，以不变应万变，也颇符合编程这个领域。函数式语言， DBC都是以静制动，以不变应万变的思路，而命令式语言则是以动为主，其复杂度自然高且难以控制。

本文仅是思考，缺少了对DBC的一些具体实践说明，后续可以进行补充，包括如下方面：
1、在Java/Scala中如何应用DBC模式？
2、复杂的后置条件检查和不变量检查是否会影响服务性能？
3、DBC模式的一些基本原则。
